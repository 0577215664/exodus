/* automatically generated by rust-bindgen */

pub const PF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const PF_LOCAL: ::std::os::raw::c_uint = 1;
pub const PF_UNIX: ::std::os::raw::c_uint = 1;
pub const PF_INET: ::std::os::raw::c_uint = 2;
pub const PF_IMPLINK: ::std::os::raw::c_uint = 3;
pub const PF_PUP: ::std::os::raw::c_uint = 4;
pub const PF_CHAOS: ::std::os::raw::c_uint = 5;
pub const PF_NS: ::std::os::raw::c_uint = 6;
pub const PF_ISO: ::std::os::raw::c_uint = 7;
pub const PF_OSI: ::std::os::raw::c_uint = 7;
pub const PF_ECMA: ::std::os::raw::c_uint = 8;
pub const PF_DATAKIT: ::std::os::raw::c_uint = 9;
pub const PF_CCITT: ::std::os::raw::c_uint = 10;
pub const PF_SNA: ::std::os::raw::c_uint = 11;
pub const PF_DECnet: ::std::os::raw::c_uint = 12;
pub const PF_DLI: ::std::os::raw::c_uint = 13;
pub const PF_LAT: ::std::os::raw::c_uint = 14;
pub const PF_HYLINK: ::std::os::raw::c_uint = 15;
pub const PF_APPLETALK: ::std::os::raw::c_uint = 16;
pub const PF_ROUTE: ::std::os::raw::c_uint = 17;
pub const PF_LINK: ::std::os::raw::c_uint = 18;
pub const PF_XTP: ::std::os::raw::c_uint = 19;
pub const PF_COIP: ::std::os::raw::c_uint = 20;
pub const PF_CNT: ::std::os::raw::c_uint = 21;
pub const PF_SIP: ::std::os::raw::c_uint = 24;
pub const PF_IPX: ::std::os::raw::c_uint = 23;
pub const PF_RTIP: ::std::os::raw::c_uint = 22;
pub const PF_PIP: ::std::os::raw::c_uint = 25;
pub const PF_NDRV: ::std::os::raw::c_uint = 27;
pub const PF_ISDN: ::std::os::raw::c_uint = 28;
pub const PF_KEY: ::std::os::raw::c_uint = 29;
pub const PF_INET6: ::std::os::raw::c_uint = 30;
pub const PF_NATM: ::std::os::raw::c_uint = 31;
pub const PF_SYSTEM: ::std::os::raw::c_uint = 32;
pub const PF_NETBIOS: ::std::os::raw::c_uint = 33;
pub const PF_PPP: ::std::os::raw::c_uint = 34;
pub const PF_RESERVED_36: ::std::os::raw::c_uint = 36;
pub const PF_UTUN: ::std::os::raw::c_uint = 38;
pub const PF_MAX: ::std::os::raw::c_uint = 40;
pub const PF_MD5_DIGEST_LENGTH: ::std::os::raw::c_uint = 16;
pub const PF_GRE_PPTP_VARIANT: ::std::os::raw::c_uint = 1;
pub const PF_POOL_IDMASK: ::std::os::raw::c_uint = 15;
pub const PF_POOL_TYPEMASK: ::std::os::raw::c_uint = 15;
pub const PF_POOL_STICKYADDR: ::std::os::raw::c_uint = 32;
pub const PF_WSCALE_FLAG: ::std::os::raw::c_uint = 128;
pub const PF_WSCALE_MASK: ::std::os::raw::c_uint = 15;
pub const PF_LOG: ::std::os::raw::c_uint = 1;
pub const PF_LOG_ALL: ::std::os::raw::c_uint = 2;
pub const PF_LOG_SOCKET_LOOKUP: ::std::os::raw::c_uint = 4;
pub const PF_TABLE_NAME_SIZE: ::std::os::raw::c_uint = 32;
pub const PF_OSFP_EXPANDED: ::std::os::raw::c_uint = 1;
pub const PF_OSFP_GENERIC: ::std::os::raw::c_uint = 2;
pub const PF_OSFP_NODETAIL: ::std::os::raw::c_uint = 4;
pub const PF_OSFP_LEN: ::std::os::raw::c_uint = 32;
pub const PF_OSFP_WSIZE_MOD: ::std::os::raw::c_uint = 1;
pub const PF_OSFP_WSIZE_DC: ::std::os::raw::c_uint = 2;
pub const PF_OSFP_WSIZE_MSS: ::std::os::raw::c_uint = 4;
pub const PF_OSFP_WSIZE_MTU: ::std::os::raw::c_uint = 8;
pub const PF_OSFP_PSIZE_MOD: ::std::os::raw::c_uint = 16;
pub const PF_OSFP_PSIZE_DC: ::std::os::raw::c_uint = 32;
pub const PF_OSFP_WSCALE: ::std::os::raw::c_uint = 64;
pub const PF_OSFP_WSCALE_MOD: ::std::os::raw::c_uint = 128;
pub const PF_OSFP_WSCALE_DC: ::std::os::raw::c_uint = 256;
pub const PF_OSFP_MSS: ::std::os::raw::c_uint = 512;
pub const PF_OSFP_MSS_MOD: ::std::os::raw::c_uint = 1024;
pub const PF_OSFP_MSS_DC: ::std::os::raw::c_uint = 2048;
pub const PF_OSFP_DF: ::std::os::raw::c_uint = 4096;
pub const PF_OSFP_TS0: ::std::os::raw::c_uint = 8192;
pub const PF_OSFP_INET6: ::std::os::raw::c_uint = 16384;
pub const PF_OSFP_MAXTTL_OFFSET: ::std::os::raw::c_uint = 40;
pub const PF_OSFP_TCPOPT_NOP: ::std::os::raw::c_uint = 0;
pub const PF_OSFP_TCPOPT_WSCALE: ::std::os::raw::c_uint = 1;
pub const PF_OSFP_TCPOPT_MSS: ::std::os::raw::c_uint = 2;
pub const PF_OSFP_TCPOPT_SACK: ::std::os::raw::c_uint = 3;
pub const PF_OSFP_TCPOPT_TS: ::std::os::raw::c_uint = 4;
pub const PF_OSFP_TCPOPT_BITS: ::std::os::raw::c_uint = 3;
pub const PF_ANCHOR_NAME_SIZE: ::std::os::raw::c_uint = 64;
pub const PF_SKIP_IFP: ::std::os::raw::c_uint = 0;
pub const PF_SKIP_DIR: ::std::os::raw::c_uint = 1;
pub const PF_SKIP_AF: ::std::os::raw::c_uint = 2;
pub const PF_SKIP_PROTO: ::std::os::raw::c_uint = 3;
pub const PF_SKIP_SRC_ADDR: ::std::os::raw::c_uint = 4;
pub const PF_SKIP_SRC_PORT: ::std::os::raw::c_uint = 5;
pub const PF_SKIP_DST_ADDR: ::std::os::raw::c_uint = 6;
pub const PF_SKIP_DST_PORT: ::std::os::raw::c_uint = 7;
pub const PF_SKIP_COUNT: ::std::os::raw::c_uint = 8;
pub const PF_RULE_LABEL_SIZE: ::std::os::raw::c_uint = 64;
pub const PF_QNAME_SIZE: ::std::os::raw::c_uint = 64;
pub const PF_TAG_NAME_SIZE: ::std::os::raw::c_uint = 64;
pub const PF_OWNER_NAME_SIZE: ::std::os::raw::c_uint = 64;
pub const PF_STATE_NORMAL: ::std::os::raw::c_uint = 1;
pub const PF_STATE_MODULATE: ::std::os::raw::c_uint = 2;
pub const PF_STATE_SYNPROXY: ::std::os::raw::c_uint = 3;
pub const PF_FLUSH: ::std::os::raw::c_uint = 1;
pub const PF_FLUSH_GLOBAL: ::std::os::raw::c_uint = 2;
pub const PF_THRESHOLD_MULT: ::std::os::raw::c_uint = 1000;
pub const PF_THRESHOLD_MAX: ::std::os::raw::c_uint = 4294967;
pub const PF_RESERVED_ANCHOR: &'static [u8; 4usize] = b"_pf\x00";
pub const PF_DPORT_RANGE: ::std::os::raw::c_uint = 1;
pub const PF_RPORT_RANGE: ::std::os::raw::c_uint = 2;
pub const PF_ALTQ_BW_ABSOLUTE: ::std::os::raw::c_uint = 1;
pub const PF_ALTQ_BW_PERCENT: ::std::os::raw::c_uint = 2;
pub const PF_ALTQF_TBR: ::std::os::raw::c_uint = 1;
pub const PF_ALTQ_QRF_WEIGHT: ::std::os::raw::c_uint = 1;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type in_addr_t = __uint32_t;
pub type pid_t = __darwin_pid_t;
pub type uid_t = __darwin_uid_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
impl Default for in6_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub const PF_INOUT: _bindgen_ty_5 = _bindgen_ty_5::PF_INOUT;
pub const PF_IN: _bindgen_ty_5 = _bindgen_ty_5::PF_IN;
pub const PF_OUT: _bindgen_ty_5 = _bindgen_ty_5::PF_OUT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 { PF_INOUT = 0, PF_IN = 1, PF_OUT = 2, }
pub const PF_PASS: _bindgen_ty_6 = _bindgen_ty_6::PF_PASS;
pub const PF_DROP: _bindgen_ty_6 = _bindgen_ty_6::PF_DROP;
pub const PF_SCRUB: _bindgen_ty_6 = _bindgen_ty_6::PF_SCRUB;
pub const PF_NOSCRUB: _bindgen_ty_6 = _bindgen_ty_6::PF_NOSCRUB;
pub const PF_NAT: _bindgen_ty_6 = _bindgen_ty_6::PF_NAT;
pub const PF_NONAT: _bindgen_ty_6 = _bindgen_ty_6::PF_NONAT;
pub const PF_BINAT: _bindgen_ty_6 = _bindgen_ty_6::PF_BINAT;
pub const PF_NOBINAT: _bindgen_ty_6 = _bindgen_ty_6::PF_NOBINAT;
pub const PF_RDR: _bindgen_ty_6 = _bindgen_ty_6::PF_RDR;
pub const PF_NORDR: _bindgen_ty_6 = _bindgen_ty_6::PF_NORDR;
pub const PF_SYNPROXY_DROP: _bindgen_ty_6 = _bindgen_ty_6::PF_SYNPROXY_DROP;
pub const PF_DUMMYNET: _bindgen_ty_6 = _bindgen_ty_6::PF_DUMMYNET;
pub const PF_NODUMMYNET: _bindgen_ty_6 = _bindgen_ty_6::PF_NODUMMYNET;
pub const PF_NAT64: _bindgen_ty_6 = _bindgen_ty_6::PF_NAT64;
pub const PF_NONAT64: _bindgen_ty_6 = _bindgen_ty_6::PF_NONAT64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    PF_PASS = 0,
    PF_DROP = 1,
    PF_SCRUB = 2,
    PF_NOSCRUB = 3,
    PF_NAT = 4,
    PF_NONAT = 5,
    PF_BINAT = 6,
    PF_NOBINAT = 7,
    PF_RDR = 8,
    PF_NORDR = 9,
    PF_SYNPROXY_DROP = 10,
    PF_DUMMYNET = 11,
    PF_NODUMMYNET = 12,
    PF_NAT64 = 13,
    PF_NONAT64 = 14,
}
pub const PF_RULESET_SCRUB: _bindgen_ty_7 = _bindgen_ty_7::PF_RULESET_SCRUB;
pub const PF_RULESET_FILTER: _bindgen_ty_7 = _bindgen_ty_7::PF_RULESET_FILTER;
pub const PF_RULESET_NAT: _bindgen_ty_7 = _bindgen_ty_7::PF_RULESET_NAT;
pub const PF_RULESET_BINAT: _bindgen_ty_7 = _bindgen_ty_7::PF_RULESET_BINAT;
pub const PF_RULESET_RDR: _bindgen_ty_7 = _bindgen_ty_7::PF_RULESET_RDR;
pub const PF_RULESET_DUMMYNET: _bindgen_ty_7 =
    _bindgen_ty_7::PF_RULESET_DUMMYNET;
pub const PF_RULESET_MAX: _bindgen_ty_7 = _bindgen_ty_7::PF_RULESET_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    PF_RULESET_SCRUB = 0,
    PF_RULESET_FILTER = 1,
    PF_RULESET_NAT = 2,
    PF_RULESET_BINAT = 3,
    PF_RULESET_RDR = 4,
    PF_RULESET_DUMMYNET = 5,
    PF_RULESET_MAX = 6,
}
pub const PF_OP_NONE: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_NONE;
pub const PF_OP_IRG: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_IRG;
pub const PF_OP_EQ: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_EQ;
pub const PF_OP_NE: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_NE;
pub const PF_OP_LT: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_LT;
pub const PF_OP_LE: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_LE;
pub const PF_OP_GT: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_GT;
pub const PF_OP_GE: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_GE;
pub const PF_OP_XRG: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_XRG;
pub const PF_OP_RRG: _bindgen_ty_8 = _bindgen_ty_8::PF_OP_RRG;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    PF_OP_NONE = 0,
    PF_OP_IRG = 1,
    PF_OP_EQ = 2,
    PF_OP_NE = 3,
    PF_OP_LT = 4,
    PF_OP_LE = 5,
    PF_OP_GT = 6,
    PF_OP_GE = 7,
    PF_OP_XRG = 8,
    PF_OP_RRG = 9,
}
pub const PF_DEBUG_NONE: _bindgen_ty_9 = _bindgen_ty_9::PF_DEBUG_NONE;
pub const PF_DEBUG_URGENT: _bindgen_ty_9 = _bindgen_ty_9::PF_DEBUG_URGENT;
pub const PF_DEBUG_MISC: _bindgen_ty_9 = _bindgen_ty_9::PF_DEBUG_MISC;
pub const PF_DEBUG_NOISY: _bindgen_ty_9 = _bindgen_ty_9::PF_DEBUG_NOISY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    PF_DEBUG_NONE = 0,
    PF_DEBUG_URGENT = 1,
    PF_DEBUG_MISC = 2,
    PF_DEBUG_NOISY = 3,
}
pub const PF_CHANGE_NONE: _bindgen_ty_10 = _bindgen_ty_10::PF_CHANGE_NONE;
pub const PF_CHANGE_ADD_HEAD: _bindgen_ty_10 =
    _bindgen_ty_10::PF_CHANGE_ADD_HEAD;
pub const PF_CHANGE_ADD_TAIL: _bindgen_ty_10 =
    _bindgen_ty_10::PF_CHANGE_ADD_TAIL;
pub const PF_CHANGE_ADD_BEFORE: _bindgen_ty_10 =
    _bindgen_ty_10::PF_CHANGE_ADD_BEFORE;
pub const PF_CHANGE_ADD_AFTER: _bindgen_ty_10 =
    _bindgen_ty_10::PF_CHANGE_ADD_AFTER;
pub const PF_CHANGE_REMOVE: _bindgen_ty_10 = _bindgen_ty_10::PF_CHANGE_REMOVE;
pub const PF_CHANGE_GET_TICKET: _bindgen_ty_10 =
    _bindgen_ty_10::PF_CHANGE_GET_TICKET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    PF_CHANGE_NONE = 0,
    PF_CHANGE_ADD_HEAD = 1,
    PF_CHANGE_ADD_TAIL = 2,
    PF_CHANGE_ADD_BEFORE = 3,
    PF_CHANGE_ADD_AFTER = 4,
    PF_CHANGE_REMOVE = 5,
    PF_CHANGE_GET_TICKET = 6,
}
pub const PF_GET_NONE: _bindgen_ty_11 = _bindgen_ty_11::PF_GET_NONE;
pub const PF_GET_CLR_CNTR: _bindgen_ty_11 = _bindgen_ty_11::PF_GET_CLR_CNTR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 { PF_GET_NONE = 0, PF_GET_CLR_CNTR = 1, }
pub const PF_NOPFROUTE: _bindgen_ty_13 = _bindgen_ty_13::PF_NOPFROUTE;
pub const PF_FASTROUTE: _bindgen_ty_13 = _bindgen_ty_13::PF_FASTROUTE;
pub const PF_ROUTETO: _bindgen_ty_13 = _bindgen_ty_13::PF_ROUTETO;
pub const PF_DUPTO: _bindgen_ty_13 = _bindgen_ty_13::PF_DUPTO;
pub const PF_REPLYTO: _bindgen_ty_13 = _bindgen_ty_13::PF_REPLYTO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    PF_NOPFROUTE = 0,
    PF_FASTROUTE = 1,
    PF_ROUTETO = 2,
    PF_DUPTO = 3,
    PF_REPLYTO = 4,
}
pub const PF_LIMIT_STATES: _bindgen_ty_14 = _bindgen_ty_14::PF_LIMIT_STATES;
pub const PF_LIMIT_APP_STATES: _bindgen_ty_14 =
    _bindgen_ty_14::PF_LIMIT_APP_STATES;
pub const PF_LIMIT_SRC_NODES: _bindgen_ty_14 =
    _bindgen_ty_14::PF_LIMIT_SRC_NODES;
pub const PF_LIMIT_FRAGS: _bindgen_ty_14 = _bindgen_ty_14::PF_LIMIT_FRAGS;
pub const PF_LIMIT_TABLES: _bindgen_ty_14 = _bindgen_ty_14::PF_LIMIT_TABLES;
pub const PF_LIMIT_TABLE_ENTRIES: _bindgen_ty_14 =
    _bindgen_ty_14::PF_LIMIT_TABLE_ENTRIES;
pub const PF_LIMIT_MAX: _bindgen_ty_14 = _bindgen_ty_14::PF_LIMIT_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    PF_LIMIT_STATES = 0,
    PF_LIMIT_APP_STATES = 1,
    PF_LIMIT_SRC_NODES = 2,
    PF_LIMIT_FRAGS = 3,
    PF_LIMIT_TABLES = 4,
    PF_LIMIT_TABLE_ENTRIES = 5,
    PF_LIMIT_MAX = 6,
}
pub const PF_POOL_NONE: _bindgen_ty_15 = _bindgen_ty_15::PF_POOL_NONE;
pub const PF_POOL_BITMASK: _bindgen_ty_15 = _bindgen_ty_15::PF_POOL_BITMASK;
pub const PF_POOL_RANDOM: _bindgen_ty_15 = _bindgen_ty_15::PF_POOL_RANDOM;
pub const PF_POOL_SRCHASH: _bindgen_ty_15 = _bindgen_ty_15::PF_POOL_SRCHASH;
pub const PF_POOL_ROUNDROBIN: _bindgen_ty_15 =
    _bindgen_ty_15::PF_POOL_ROUNDROBIN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    PF_POOL_NONE = 0,
    PF_POOL_BITMASK = 1,
    PF_POOL_RANDOM = 2,
    PF_POOL_SRCHASH = 3,
    PF_POOL_ROUNDROBIN = 4,
}
pub const PF_ADDR_ADDRMASK: _bindgen_ty_16 = _bindgen_ty_16::PF_ADDR_ADDRMASK;
pub const PF_ADDR_NOROUTE: _bindgen_ty_16 = _bindgen_ty_16::PF_ADDR_NOROUTE;
pub const PF_ADDR_DYNIFTL: _bindgen_ty_16 = _bindgen_ty_16::PF_ADDR_DYNIFTL;
pub const PF_ADDR_TABLE: _bindgen_ty_16 = _bindgen_ty_16::PF_ADDR_TABLE;
pub const PF_ADDR_RTLABEL: _bindgen_ty_16 = _bindgen_ty_16::PF_ADDR_RTLABEL;
pub const PF_ADDR_URPFFAILED: _bindgen_ty_16 =
    _bindgen_ty_16::PF_ADDR_URPFFAILED;
pub const PF_ADDR_RANGE: _bindgen_ty_16 = _bindgen_ty_16::PF_ADDR_RANGE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 {
    PF_ADDR_ADDRMASK = 0,
    PF_ADDR_NOROUTE = 1,
    PF_ADDR_DYNIFTL = 2,
    PF_ADDR_TABLE = 3,
    PF_ADDR_RTLABEL = 4,
    PF_ADDR_URPFFAILED = 5,
    PF_ADDR_RANGE = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_addr {
    pub pfa: pf_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union pf_addr__bindgen_ty_1 {
    pub v4: in_addr,
    pub v6: in6_addr,
    pub addr8: [u_int8_t; 16usize],
    pub addr16: [u_int16_t; 8usize],
    pub addr32: [u_int32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Clone for pf_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_addr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_addr {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_addr_wrap {
    pub v: pf_addr_wrap__bindgen_ty_1,
    pub p: pf_addr_wrap__bindgen_ty_2,
    pub type_: u_int8_t,
    pub iflags: u_int8_t,
}
#[repr(C)]
#[derive(Copy)]
pub union pf_addr_wrap__bindgen_ty_1 {
    pub a: pf_addr_wrap__bindgen_ty_1__bindgen_ty_1,
    pub ifname: [::std::os::raw::c_char; 16usize],
    pub tblname: [::std::os::raw::c_char; 32usize],
    pub rtlabelname: [::std::os::raw::c_char; 32usize],
    pub rtlabel: u_int32_t,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_addr_wrap__bindgen_ty_1__bindgen_ty_1 {
    pub addr: pf_addr,
    pub mask: pf_addr,
}
impl Clone for pf_addr_wrap__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_addr_wrap__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_addr_wrap__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_addr_wrap__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union pf_addr_wrap__bindgen_ty_2 {
    pub dyn: *mut ::std::os::raw::c_void,
    pub tbl: *mut ::std::os::raw::c_void,
    pub dyncnt: ::std::os::raw::c_int,
    pub tblcnt: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
impl Clone for pf_addr_wrap__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_addr_wrap__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_addr_wrap {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_addr_wrap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pf_port_range {
    pub port: [u_int16_t; 2usize],
    pub op: u_int8_t,
}
impl Clone for pf_port_range {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pf_rule_xport {
    pub range: pf_port_range,
    pub call_id: u_int16_t,
    pub spi: u_int32_t,
    _bindgen_union_align: [u32; 2usize],
}
impl Clone for pf_rule_xport {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_rule_xport {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pf_rule_uid {
    pub uid: [uid_t; 2usize],
    pub op: u_int8_t,
    pub _pad: [u_int8_t; 3usize],
}
impl Clone for pf_rule_uid {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pf_rule_gid {
    pub gid: [uid_t; 2usize],
    pub op: u_int8_t,
    pub _pad: [u_int8_t; 3usize],
}
impl Clone for pf_rule_gid {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_rule_addr {
    pub addr: pf_addr_wrap,
    pub xport: pf_rule_xport,
    pub neg: u_int8_t,
}
impl Clone for pf_rule_addr {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_rule_addr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_pooladdr {
    pub addr: pf_addr_wrap,
    pub entries: pf_pooladdr__bindgen_ty_1,
    pub ifname: [::std::os::raw::c_char; 16usize],
    pub kif: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_pooladdr__bindgen_ty_1 {
    pub tqe_next: *mut pf_pooladdr,
    pub tqe_prev: *mut *mut pf_pooladdr,
}
impl Clone for pf_pooladdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_pooladdr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_pooladdr {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_pooladdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_palist {
    pub tqh_first: *mut pf_pooladdr,
    pub tqh_last: *mut *mut pf_pooladdr,
}
impl Clone for pf_palist {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_palist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_poolhashkey {
    pub pfk: pf_poolhashkey__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union pf_poolhashkey__bindgen_ty_1 {
    pub key8: [u_int8_t; 16usize],
    pub key16: [u_int16_t; 8usize],
    pub key32: [u_int32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Clone for pf_poolhashkey__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_poolhashkey__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_poolhashkey {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_poolhashkey {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_pool {
    pub list: pf_palist,
    pub cur: *mut ::std::os::raw::c_void,
    pub key: pf_poolhashkey,
    pub counter: pf_addr,
    pub tblidx: ::std::os::raw::c_int,
    pub proxy_port: [u_int16_t; 2usize],
    pub port_op: u_int8_t,
    pub opts: u_int8_t,
    pub af: sa_family_t,
}
impl Clone for pf_pool {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_pool {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pf_osfp_t = u_int32_t;
#[repr(C)]
#[derive(Copy)]
pub union pf_rule_ptr {
    pub ptr: *mut pf_rule,
    pub nr: u_int32_t,
    _bindgen_union_align: u64,
}
impl Clone for pf_rule_ptr {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_rule_ptr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_rule {
    pub src: pf_rule_addr,
    pub dst: pf_rule_addr,
    pub skip: [pf_rule_ptr; 8usize],
    pub label: [::std::os::raw::c_char; 64usize],
    pub ifname: [::std::os::raw::c_char; 16usize],
    pub qname: [::std::os::raw::c_char; 64usize],
    pub pqname: [::std::os::raw::c_char; 64usize],
    pub tagname: [::std::os::raw::c_char; 64usize],
    pub match_tagname: [::std::os::raw::c_char; 64usize],
    pub overload_tblname: [::std::os::raw::c_char; 32usize],
    pub entries: pf_rule__bindgen_ty_1,
    pub rpool: pf_pool,
    pub evaluations: u_int64_t,
    pub packets: [u_int64_t; 2usize],
    pub bytes: [u_int64_t; 2usize],
    pub ticket: u_int64_t,
    pub owner: [::std::os::raw::c_char; 64usize],
    pub priority: u_int32_t,
    pub kif: *mut ::std::os::raw::c_void,
    pub anchor: *mut pf_anchor,
    pub overload_tbl: *mut ::std::os::raw::c_void,
    pub os_fingerprint: pf_osfp_t,
    pub rtableid: ::std::os::raw::c_uint,
    pub timeout: [u_int32_t; 26usize],
    pub states: u_int32_t,
    pub max_states: u_int32_t,
    pub src_nodes: u_int32_t,
    pub max_src_nodes: u_int32_t,
    pub max_src_states: u_int32_t,
    pub max_src_conn: u_int32_t,
    pub max_src_conn_rate: pf_rule__bindgen_ty_2,
    pub qid: u_int32_t,
    pub pqid: u_int32_t,
    pub rt_listid: u_int32_t,
    pub nr: u_int32_t,
    pub prob: u_int32_t,
    pub cuid: uid_t,
    pub cpid: pid_t,
    pub return_icmp: u_int16_t,
    pub return_icmp6: u_int16_t,
    pub max_mss: u_int16_t,
    pub tag: u_int16_t,
    pub match_tag: u_int16_t,
    pub uid: pf_rule_uid,
    pub gid: pf_rule_gid,
    pub rule_flag: u_int32_t,
    pub action: u_int8_t,
    pub direction: u_int8_t,
    pub log: u_int8_t,
    pub logif: u_int8_t,
    pub quick: u_int8_t,
    pub ifnot: u_int8_t,
    pub match_tag_not: u_int8_t,
    pub natpass: u_int8_t,
    pub keep_state: u_int8_t,
    pub af: sa_family_t,
    pub proto: u_int8_t,
    pub type_: u_int8_t,
    pub code: u_int8_t,
    pub flags: u_int8_t,
    pub flagset: u_int8_t,
    pub min_ttl: u_int8_t,
    pub allow_opts: u_int8_t,
    pub rt: u_int8_t,
    pub return_ttl: u_int8_t,
    pub tos: u_int8_t,
    pub anchor_relative: u_int8_t,
    pub anchor_wildcard: u_int8_t,
    pub flush: u_int8_t,
    pub proto_variant: u_int8_t,
    pub extfilter: u_int8_t,
    pub extmap: u_int8_t,
    pub dnpipe: u_int32_t,
    pub dntype: u_int32_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_rule__bindgen_ty_1 {
    pub tqe_next: *mut pf_rule,
    pub tqe_prev: *mut *mut pf_rule,
}
impl Clone for pf_rule__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_rule__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pf_rule__bindgen_ty_2 {
    pub limit: u_int32_t,
    pub seconds: u_int32_t,
}
impl Clone for pf_rule__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Clone for pf_rule {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_rule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union pf_state_xport {
    pub port: u_int16_t,
    pub call_id: u_int16_t,
    pub spi: u_int32_t,
    _bindgen_union_align: u32,
}
impl Clone for pf_state_xport {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_state_xport {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hook_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hook_desc_head {
    pub tqh_first: *mut hook_desc,
    pub tqh_last: *mut *mut hook_desc,
}
impl Clone for hook_desc_head {
    fn clone(&self) -> Self { *self }
}
impl Default for hook_desc_head {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct pfsync_state_scrub {
    pub pfss_flags: u_int16_t,
    pub pfss_ttl: u_int8_t,
    pub scrub_flag: u_int8_t,
    pub pfss_ts_mod: u_int32_t,
}
impl Clone for pfsync_state_scrub {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct pfsync_state_host {
    pub addr: pf_addr,
    pub xport: pf_state_xport,
    pub pad: [u_int16_t; 2usize],
}
impl Clone for pfsync_state_host {
    fn clone(&self) -> Self { *self }
}
impl Default for pfsync_state_host {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct pfsync_state_peer {
    pub scrub: pfsync_state_scrub,
    pub seqlo: u_int32_t,
    pub seqhi: u_int32_t,
    pub seqdiff: u_int32_t,
    pub max_win: u_int16_t,
    pub mss: u_int16_t,
    pub state: u_int8_t,
    pub wscale: u_int8_t,
    pub pad: [u_int8_t; 6usize],
}
impl Clone for pfsync_state_peer {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct pfsync_state {
    pub id: [u_int32_t; 2usize],
    pub ifname: [::std::os::raw::c_char; 16usize],
    pub lan: pfsync_state_host,
    pub gwy: pfsync_state_host,
    pub ext_lan: pfsync_state_host,
    pub ext_gwy: pfsync_state_host,
    pub src: pfsync_state_peer,
    pub dst: pfsync_state_peer,
    pub rt_addr: pf_addr,
    pub unlink_hooks: hook_desc_head,
    pub rule: u_int32_t,
    pub anchor: u_int32_t,
    pub nat_rule: u_int32_t,
    pub creation: u_int64_t,
    pub expire: u_int64_t,
    pub packets: [[u_int32_t; 2usize]; 2usize],
    pub bytes: [[u_int32_t; 2usize]; 2usize],
    pub creatorid: u_int32_t,
    pub tag: u_int16_t,
    pub af_lan: sa_family_t,
    pub af_gwy: sa_family_t,
    pub proto: u_int8_t,
    pub direction: u_int8_t,
    pub log: u_int8_t,
    pub allow_opts: u_int8_t,
    pub timeout: u_int8_t,
    pub sync_flags: u_int8_t,
    pub updates: u_int8_t,
    pub proto_variant: u_int8_t,
    pub __pad: u_int8_t,
    pub flowhash: u_int32_t,
}
impl Clone for pfsync_state {
    fn clone(&self) -> Self { *self }
}
impl Default for pfsync_state {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_rulequeue {
    pub tqh_first: *mut pf_rule,
    pub tqh_last: *mut *mut pf_rule,
}
impl Clone for pf_rulequeue {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_rulequeue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pf_anchor {
    pub entry_global: pf_anchor__bindgen_ty_1,
    pub entry_node: pf_anchor__bindgen_ty_2,
    pub parent: *mut pf_anchor,
    pub children: pf_anchor_node,
    pub name: [::std::os::raw::c_char; 64usize],
    pub path: [::std::os::raw::c_char; 1024usize],
    pub ruleset: pf_ruleset,
    pub refcnt: ::std::os::raw::c_int,
    pub match_: ::std::os::raw::c_int,
    pub owner: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_anchor__bindgen_ty_1 {
    pub rbe_left: *mut pf_anchor,
    pub rbe_right: *mut pf_anchor,
    pub rbe_parent: *mut pf_anchor,
}
impl Clone for pf_anchor__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_anchor__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_anchor__bindgen_ty_2 {
    pub rbe_left: *mut pf_anchor,
    pub rbe_right: *mut pf_anchor,
    pub rbe_parent: *mut pf_anchor,
}
impl Clone for pf_anchor__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_anchor__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_anchor {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_anchor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_ruleset {
    pub rules: [pf_ruleset__bindgen_ty_1; 6usize],
    pub anchor: *mut pf_anchor,
    pub tticket: u_int32_t,
    pub tables: ::std::os::raw::c_int,
    pub topen: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_ruleset__bindgen_ty_1 {
    pub queues: [pf_rulequeue; 2usize],
    pub active: pf_ruleset__bindgen_ty_1__bindgen_ty_1,
    pub inactive: pf_ruleset__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_ruleset__bindgen_ty_1__bindgen_ty_1 {
    pub ptr: *mut pf_rulequeue,
    pub ptr_array: *mut *mut pf_rule,
    pub rcount: u_int32_t,
    pub ticket: u_int32_t,
    pub open: ::std::os::raw::c_int,
}
impl Clone for pf_ruleset__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_ruleset__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_ruleset__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_ruleset__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pf_ruleset {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_ruleset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pf_anchor_node {
    pub rbh_root: *mut pf_anchor,
}
impl Clone for pf_anchor_node {
    fn clone(&self) -> Self { *self }
}
impl Default for pf_anchor_node {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pf_status {
    pub counters: [u_int64_t; 16usize],
    pub lcounters: [u_int64_t; 7usize],
    pub fcounters: [u_int64_t; 3usize],
    pub scounters: [u_int64_t; 3usize],
    pub pcounters: [[[u_int64_t; 3usize]; 2usize]; 2usize],
    pub bcounters: [[u_int64_t; 2usize]; 2usize],
    pub stateid: u_int64_t,
    pub running: u_int32_t,
    pub states: u_int32_t,
    pub src_nodes: u_int32_t,
    pub since: u_int64_t,
    pub debug: u_int32_t,
    pub hostid: u_int32_t,
    pub ifname: [::std::os::raw::c_char; 16usize],
    pub pf_chksum: [u_int8_t; 16usize],
}
impl Clone for pf_status {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct pfioc_pooladdr {
    pub action: u_int32_t,
    pub ticket: u_int32_t,
    pub nr: u_int32_t,
    pub r_num: u_int32_t,
    pub r_action: u_int8_t,
    pub r_last: u_int8_t,
    pub af: u_int8_t,
    pub anchor: [::std::os::raw::c_char; 1024usize],
    pub addr: pf_pooladdr,
}
impl Clone for pfioc_pooladdr {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_pooladdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pfioc_rule {
    pub action: u_int32_t,
    pub ticket: u_int32_t,
    pub pool_ticket: u_int32_t,
    pub nr: u_int32_t,
    pub anchor: [::std::os::raw::c_char; 1024usize],
    pub anchor_call: [::std::os::raw::c_char; 1024usize],
    pub rule: pf_rule,
}
impl Clone for pfioc_rule {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_rule {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pfioc_state_addr_kill {
    pub addr: pf_addr_wrap,
    pub reserved_: [u_int8_t; 3usize],
    pub neg: u_int8_t,
    pub xport: pf_rule_xport,
}
impl Clone for pfioc_state_addr_kill {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_state_addr_kill {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pfioc_state_kill {
    pub psk_af: sa_family_t,
    pub psk_proto: u_int8_t,
    pub psk_proto_variant: u_int8_t,
    pub _pad: u_int8_t,
    pub psk_src: pfioc_state_addr_kill,
    pub psk_dst: pfioc_state_addr_kill,
    pub psk_ifname: [::std::os::raw::c_char; 16usize],
    pub psk_ownername: [::std::os::raw::c_char; 64usize],
}
impl Clone for pfioc_state_kill {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_state_kill {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pfioc_states {
    pub ps_len: ::std::os::raw::c_int,
    pub ps_u: pfioc_states__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union pfioc_states__bindgen_ty_1 {
    pub psu_buf: caddr_t,
    pub psu_states: *mut pfsync_state,
    _bindgen_union_align: u64,
}
impl Clone for pfioc_states__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_states__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pfioc_states {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_states {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pfioc_trans {
    pub size: ::std::os::raw::c_int,
    pub esize: ::std::os::raw::c_int,
    pub array: *mut pfioc_trans_pfioc_trans_e,
}
#[repr(C)]
#[derive(Copy)]
pub struct pfioc_trans_pfioc_trans_e {
    pub rs_num: ::std::os::raw::c_int,
    pub anchor: [::std::os::raw::c_char; 1024usize],
    pub ticket: u_int32_t,
}
impl Clone for pfioc_trans_pfioc_trans_e {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_trans_pfioc_trans_e {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl Clone for pfioc_trans {
    fn clone(&self) -> Self { *self }
}
impl Default for pfioc_trans {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
